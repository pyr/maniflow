<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title># Lifecycle management</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Maniflow</span> <span class="project-version">0.1.5</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span># Lifecycle management</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>manifold</span></div></div></li><li class="depth-2"><a href="manifold.lifecycle.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lifecycle</span></div></a></li><li class="depth-3"><a href="manifold.lifecycle.timing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timing</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#maniflow-utilities-on-top-of-manifold" name="maniflow-utilities-on-top-of-manifold"></a>maniflow: utilities on top of manifold</h1>
<p><a href="http://travis-ci.org/pyr/maniflow"><img src="https://secure.travis-ci.org/pyr/maniflow.png" alt="Build Status" /></a></p>
<pre><code class="clojure">[spootnik/maniflow "0.1.5"]
</code></pre>
<h2><a href="#lifecycle-management" name="lifecycle-management"></a>Lifecycle management</h2>
<p>The <code>manifold.lifecycle</code> namespace provides a lightweight take on a mechanism similar to <a href="http://pedestal.io/reference/interceptors">interceptors</a> or <a href="https://github.com/metosin/sieppari">sieppari</a>.</p>
<p>A lifecycle is nothing more than a collection of handlers through which a value is passed.</p>
<p>In essence:</p>
<pre><code class="clojure">@(run 0 [(step inc) (step inc) (step inc)])
</code></pre>
<p>Is thus directly equivalent to:</p>
<pre><code class="clojure">(-&gt; 0 inc inc inc)
</code></pre>
<h3><a href="#lifecycle-steps" name="lifecycle-steps"></a>Lifecycle steps</h3>
<p>As shown above, each step in a lifecycle is a handler to run on a value. Steps can be provided in several forms, all coerced to a map.</p>
<pre><code class="clojure">{:id      :doubler
 :handler (fn [input] (* input 2))
 :guard   (fn [context] ...)}
</code></pre>
<h4><a href="#function-steps" name="function-steps"></a>Function steps</h4>
<p>When a step is a plain function, as in <code>(run 0 [inc])</code>, the resulting map will be of the following shape:</p>
<pre><code class="clojure">{:id      :step12345
 :handler inc}
</code></pre>
<p>If the function is provided as a var, the qualified name of the var is used as the id, so for <code>(run 0 [#'inc])</code> we would have instead:</p>
<pre><code class="clojure">{:id      :inc
 :handler inc}
</code></pre>
<h4><a href="#accessing-parts-of-the-input" name="accessing-parts-of-the-input"></a>Accessing parts of the input</h4>
<p>Often times, the payload being threaded between lifecycle steps will be a map. As with interceptors, it might be useful to hold on to information accumulated during the chain processing. To help with this, maniflow provides three parameters for steps:</p>
<ul>
  <li><code>:in</code>: specifies a path that will be extracted from the payload and  fed as input to the handler</li>
  <li><code>:out</code>: specifies where in the payload to assoc the result of the  handler</li>
  <li><code>:lens</code>: when present, supersedes the previous two parameters and  acts as though both <code>:in</code> and <code>:out</code> where provided</li>
</ul>
<pre><code class="clojure">{:id      :determine-deserialize
 :handler (partial = :post)
 :in      [:request :request-method]
 :out     [::need-deserialize?])
</code></pre>
<h4><a href="#step-guards" name="step-guards"></a>Step guards</h4>
<p>Based on the current state of processing, it might be useful to guard execution of a step against a predicate, keeping with the last example:</p>
<pre><code class="clojure">{:id      :deserialize
 :handler deserialize
 :lens    [:request :body]
 :guard   ::need-deserialize?}
</code></pre>
<h4><a href="#discarding-results" name="discarding-results"></a>Discarding results</h4>
<p>Sometimes, </p>
<pre><code class="clojure">{:id       :debug
 :handler  prn
 :discard? true}
</code></pre>
<h4><a href="#building-steps-with" name="building-steps-with"></a>Building steps with <code>step</code></h4>
<p>The <code>manifold.lifecycle/step</code> function is provided to build steps easily, the above can thus be rewritten:</p>
<pre><code class="clojure">(step :determine-deserialize (partial = :post) :in [:request :request-method] :out ::need-deserialize?)
(step :debug prn :discard? true)
(step :deserialize deserialize :guard ::need-deserialize?)
(step :handler run-handler)
</code></pre>
<h3><a href="#global-options" name="global-options"></a>Global options</h3>
<p>When running a lifecycle, an options map can be passed in to further modify the behavior:</p>
<pre><code class="clojure">{:augment    (fn [context step] ...)
 :initialize (fn [value] ...)
 :executor   ...}
</code></pre>
<ul>
  <li><code>augment</code>: A function of context and current step called for each step  in the lifecycle.</li>
  <li><code>initialize</code>: A function of init value to prepare the payload.</li>
  <li><code>executor</code>: An executor to defer execution on.</li>
</ul>
<h3><a href="#error-handling" name="error-handling"></a>Error handling</h3>
<p>There are intentionally no facilities to interact with the sequence of steps in this library. Exceptions thrown will break the sequence of steps, users of the library are encouraged to use <code>manifold.deferred/catch</code> to handle errors raised during execution.</p>
<p>All errors contain the underlying thrown exception as a cause and contain the last known context in their <code>ex-data</code></p>
<pre><code class="clojure">(-&gt; (d/run 0 [(step inc) (step #(d/future (/ % 0))) (step inc)])
    (d/catch (fn [e]
	            (type (.getCause e))   ;; ArithmeticException
				(:context (ex-data e)) ;; last context)))
</code></pre>
<h3><a href="#timing-wrapper" name="timing-wrapper"></a>Timing wrapper</h3>
<p>Assuming a map payload, timing can be recorded for each step with the <code>initialize</code> and <code>augment</code> implementations provided in <code>manifold.lifecycle.timing</code>:</p>
<pre><code class="clojure"><br />@(run
  {:x 0}
  [(step :inc inc :lens :x) (step :inc inc :lens :x)]
  timing/milliseconds)

{:timing
 {:created-at 1569080525132,
  :updated-at 1569080525133,
  :index 2,
  :output [{:id :inc, :timing 0} {:id :inc, :timing 1}]},
 :x 2}
</code></pre></div></div></div></body></html>